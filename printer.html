<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Control Imprimantă NIIMBOT</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined" rel="stylesheet"/>
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator/qrcode.js"></script>
    <style>
        .dot { height: 10px; width: 10px; border-radius: 50%; display: inline-block; }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">

<div class="w-full max-w-md mx-auto bg-white rounded-2xl shadow-lg p-6">
    <div class="text-center">
        <span class="material-symbols-outlined text-6xl text-blue-600">print</span>
        <h1 class="text-2xl font-bold text-gray-800 mt-2">
            Control Imprimantă <span class="text-sm font-normal text-gray-400">v-niimprintx-7</span>
        </h1>
        <p id="status" class="text-gray-500 mt-1">Conectează-te pentru a putea imprima.</p>
    </div>

    <div class="mt-6">
        <button id="connect-btn" class="w-full flex items-center justify-center gap-2 rounded-lg bg-blue-600 py-3 text-base font-bold text-white shadow-md hover:bg-blue-700">
            <span class="material-symbols-outlined">bluetooth_searching</span>
            Conectare la Imprimantă
        </button>
        <div class="mt-2 flex items-center justify-center gap-2">
            <span id="connection-dot" class="dot bg-gray-400"></span>
            <span id="connection-text" class="text-xs text-gray-500">Deconectat</span>
        </div>
    </div>

    <hr class="my-6 border-gray-200">

    <div>
        <label for="print-text-input" class="block text-sm font-medium text-gray-700">Cod pentru QR și Text:</label>
        <input type="text" id="print-text-input" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm" value="B08ZSFS4J6CN" placeholder="ex: B08ZSFS4J6CN">
        
        <button id="print-btn" class="mt-4 w-full rounded-lg bg-gray-300 py-3 text-base font-bold text-white cursor-not-allowed" disabled>
            Imprimă Eticheta
        </button>
    </div>
    
    <div class="text-center mt-6">
         <a href="products.html" class="text-sm text-blue-600 hover:underline">Înapoi la Produse</a>
    </div>
</div>

<script>
// --- COD FINAL DE IMPRIMARE (v-niimprintx-7) ---

const connectBtn = document.getElementById('connect-btn');
const printBtn = document.getElementById('print-btn');
const textInput = document.getElementById('print-text-input');
const statusP = document.getElementById('status');
const connectionDot = document.getElementById('connection-dot');
const connectionText = document.getElementById('connection-text');

let niimbotCharacteristic = null;
let responseResolver = null;

function createNiimbotPacket(type, data) {
    const dataBytes = Array.isArray(data) ? data : [data];
    const checksum = dataBytes.reduce((acc, byte) => acc ^ byte, type ^ dataBytes.length);
    const packet = [0x55, 0x55, type, dataBytes.length, ...dataBytes, checksum, 0xAA, 0xAA];
    return new Uint8Array(packet);
}

function handleCharacteristicValueChanged(event) {
    if (responseResolver) {
        const value = new Uint8Array(event.target.value.buffer);
        responseResolver(value);
        responseResolver = null;
    }
}

async function sendCommandAndWait(characteristic, packet) {
    return new Promise((resolve, reject) => {
        responseResolver = resolve;
        const timeout = setTimeout(() => {
            if (responseResolver) {
                responseResolver = null;
                reject(new Error('Timeout: Printer did not respond.'));
            }
        }, 5000);

        characteristic.writeValueWithoutResponse(packet).catch(err => {
            clearTimeout(timeout);
            reject(err);
        });
    });
}

async function connectToPrinter() {
    if (niimbotCharacteristic) {
        statusP.textContent = "Deja conectat.";
        return;
    }
    try {
        statusP.textContent = 'Se caută imprimante...';
        const device = await navigator.bluetooth.requestDevice({
            filters: [{ namePrefix: 'D' }],
            optionalServices: ['e7810a71-73ae-499d-8c15-faa9aef0c3f2', '49535343-fe7d-4ae5-8fa9-9fafd205e455']
        });
        
        statusP.textContent = `Conectare la ${device.name}...`;
        const server = await device.gatt.connect();
        
        statusP.textContent = 'Se accesează serviciile...';
        const services = await server.getPrimaryServices();
        
        statusP.textContent = 'Se caută caracteristica potrivită...';
        
        let foundCharacteristic = null;
        for (const service of services) {
            const characteristics = await service.getCharacteristics();
            for (const char of characteristics) {
                if (char.properties.writeWithoutResponse && char.properties.notify) {
                    foundCharacteristic = char;
                    break; 
                }
            }
            if (foundCharacteristic) break;
        }

        if (!foundCharacteristic) {
            statusP.textContent = 'Eroare: Nu am găsit o caracteristică potrivită pentru imprimare.';
            server.disconnect();
            return;
        }
        
        niimbotCharacteristic = foundCharacteristic;
        
        await niimbotCharacteristic.startNotifications();
        niimbotCharacteristic.addEventListener('characteristicvaluechanged', handleCharacteristicValueChanged);
        
        statusP.textContent = `Conectat la ${device.name}. Gata de imprimare.`;
        connectionDot.classList.remove('bg-gray-400');
        connectionDot.classList.add('bg-green-500');
        connectionText.textContent = 'Conectat';
        printBtn.disabled = false;
        printBtn.classList.remove('bg-gray-300', 'cursor-not-allowed');
        printBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
        connectBtn.textContent = 'Conectat';
    } catch (error) {
        statusP.textContent = `Eroare: ${error.message}`;
    }
}

// --- FUNCȚIA DE PRINTARE MODIFICATĂ COMPLET ---
async function printLabel(textToPrint) {
    if (!niimbotCharacteristic) {
        alert("Imprimanta nu este conectată.");
        return;
    }
    if (!textToPrint) {
        alert("Introduceți un text pentru a imprima.");
        return;
    }

    try {
        statusP.textContent = 'Se pregătește eticheta...';

        const labelWidth = 240;  // 30mm
        const labelHeight = 120; // 15mm

        const canvas = document.createElement('canvas');
        canvas.width = labelHeight; // Lățimea canvas-ului devine înălțimea etichetei
        canvas.height = labelWidth; // Înălțimea canvas-ului devine lățimea etichetei

        const ctx = canvas.getContext('2d');
        
        // --- DESENARE ETICHETĂ ---
        // Fundal negru, elemente albe
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Salvăm contextul nerotit
        ctx.save();
        
        // Rotim totul cu 90 de grade
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.rotate(90 * Math.PI / 180);

        // ETAPA 1: Generare cod QR ca imagine Data URL
        const qr = qrcode(0, 'M');
        qr.addData(textToPrint);
        qr.make();
        // Căsuța de 8px, margin de 2*8=16px
        const qrImg = new Image();
        qrImg.src = qr.createDataURL(8, 2);

        // Așteptăm încărcarea imaginii QR
        await new Promise(resolve => { qrImg.onload = resolve; });

        // ETAPA 2: Desenare elemente
        // Desenăm imaginea QR. Coordonatele sunt relative la canvas-ul rotit.
        // Originea (0,0) e centrul.
        const qrSize = 100;
        ctx.drawImage(qrImg, -labelWidth / 2 + 10, -labelHeight / 2 + 10, qrSize, qrSize);

        // Desenăm textul. Îl împărțim în două dacă e prea lung.
        ctx.fillStyle = 'white';
        ctx.font = 'bold 38px Arial'; // Font mai mare, ~12pt
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle';

        const textX = -labelWidth / 2 + qrSize + 25; // Poziționare la dreapta de QR
        
        if (textToPrint.length > 7) {
            const mid = Math.ceil(textToPrint.length / 2);
            const text1 = textToPrint.substring(0, mid);
            const text2 = textToPrint.substring(mid);
            ctx.fillText(text1, textX, 0 - 20); // Linia de sus
            ctx.fillText(text2, textX, 0 + 20); // Linia de jos
        } else {
            ctx.fillText(textToPrint, textX, 0); // O singură linie
        }

        // Restaurăm contextul la starea inițială (nerotit)
        ctx.restore();
        
        // --- SFÂRȘIT DESENARE ---
        
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const imagePackets = [];
        const widthInBytes = Math.ceil(canvas.width / 8);

        for (let y = 0; y < canvas.height; y++) {
            let lineBytes = new Uint8Array(widthInBytes);
            for (let x = 0; x < canvas.width; x++) {
                const pixelIndex = (y * canvas.width + x) * 4;
                const pixelValue = imageData.data[pixelIndex] > 128 ? 1 : 0;
                if (pixelValue === 1) {
                    lineBytes[Math.floor(x / 8)] |= (1 << (7 - (x % 8)));
                }
            }
            const header = [(y >> 8) & 0xFF, y & 0xFF, 0, 0, 0, 1];
            const dataPayload = Array.from(new Uint8Array([...header, ...lineBytes]));
            imagePackets.push(createNiimbotPacket(0x85, dataPayload));
        }

        const delay = ms => new Promise(res => setTimeout(res, ms));

        statusP.textContent = 'Se trimit comenzile...';

        await sendCommandAndWait(niimbotCharacteristic, createNiimbotPacket(0x21, [3]));
        await sendCommandAndWait(niimbotCharacteristic, createNiimbotPacket(0x23, [1]));
        await sendCommandAndWait(niimbotCharacteristic, createNiimbotPacket(0x01, [1]));
        await sendCommandAndWait(niimbotCharacteristic, createNiimbotPacket(0x03, [1]));

        const dimensionData = [
            (canvas.height >> 8) & 0xFF, canvas.height & 0xFF,
            (canvas.width >> 8) & 0xFF, canvas.width & 0xFF
        ];
        await sendCommandAndWait(niimbotCharacteristic, createNiimbotPacket(0x13, dimensionData));
        await sendCommandAndWait(niimbotCharacteristic, createNiimbotPacket(0x15, [0, 1]));

        statusP.textContent = 'Se transferă datele etichetei...';
        for (const packet of imagePackets) {
            await niimbotCharacteristic.writeValueWithoutResponse(packet);
            await delay(20);
        }

        await sendCommandAndWait(niimbotCharacteristic, createNiimbotPacket(0xE3, [1]));
        await sendCommandAndWait(niimbotCharacteristic, createNiimbotPacket(0xF3, [1]));

        statusP.textContent = 'Comandă trimisă cu succes!';
    } catch (error) {
        statusP.textContent = `Eroare la imprimare: ${error.message}`;
    }
}

connectBtn.addEventListener('click', connectToPrinter);
printBtn.addEventListener('click', () => {
    const text = textInput.value;
    printLabel(text);
});

document.addEventListener('DOMContentLoaded', () => {
    const urlParams = new URLSearchParams(window.location.search);
    const textToPrint = urlParams.get('text');
    if (textToPrint) {
        textInput.value = textToPrint;
    }
});
</script>
</body>
</html>
